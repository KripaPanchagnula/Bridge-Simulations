#!/usr/bin/python3
#File: src.utils.py
"""Module containing useful functions to be used elsewhere."""


from typing import List, Tuple, Union
from itertools import permutations, product
from src.types import Card, Suit, Rank
from src.contract import Contract


def convert_card_to_number(card: Card) -> int:
    r""" Converts a Card object into a number.

    This takes the value of the suit indicated by the Suit enum and the rank value
    indicated by the Rank enum and returns Suit * 100 + Rank.

    Parameters
    ----------
    card : Card
        The card being converted to an integer.

    Returns
    -------
    number : int
        Value of Card.
    """
    return card.suit * 100 + card.rank


def convert_number_to_card(number: int) -> Card:
    r""" Converts the numerical value of the Card, back into a Card object.

    The suit value is given by the quotient of number/100, and the rank is given by the
    remainder of number/100. These are converted to strings by the relevant Suit/Rank enum,
    and a Card is created.

    Parameters
    ----------
    number : int
        Value of Card

    Returns
    -------
    card : Card
        Card object

    """
    suit = Suit(number//100).name
    rank = Rank(number % 100).name
    return Card(rank+suit)


def generate_allowed_shapes(shape: str) -> List[Tuple]:
    r""" Generates a list of hand shapes given constraints given in the shape string.

    The shape string must contain 4 integers which sum to 13, and if lengths of suit are
    interchangeable, they must be separated by "/". This can also be used to fix single lengths.
    The string must contain "-" between consecutive integers defining a suit length.
    For example:
        "/3-4/5/1" should generate the hand shapes of "3-4-5-1" and "4-3-5-1".

    This is generated by initially splitting the string by the "/" character and then splitting
    by the "-" character to generate a list of lists: [["3","4"],["5"],["1"]].
    Then each sub-list has all its permutations produced, giving
    [[["3","4"],["4","3"]],[["5"]],[["1"]]].
    Then the these lists are joined together taking 1 element from each sub-list
    to form ["3451", "4351"].
    Each 4 digit string is then converted to a 4-tuple to be of the form identical to Hand.shape

    Parameters
    ----------
    shape : str
        Starting shape to generate permutations of with various constraints.

    Returns
    -------
    allowed_shapes : list(4-tuple)
        Allowed permutations given the initial shape and constraints.
    """
    permutable_lengths = shape.split("/")
    permutable_lists = [sub_shape.split("-")
                        for sub_shape in permutable_lengths]
    permuted_subshapes = [list(permutations(permutable_lists[i]))
                          for i in range(len(permutable_lists))]
    allowed_shapes_strings = ["".join("".join(i) for i in j)
                              for j in product(*permuted_subshapes)]
    allowed_shapes = [tuple(int(shape[i]) for i in range(4))
                      for shape in allowed_shapes_strings]
    return allowed_shapes


def check_is_balanced(shape: tuple, semi: bool = False) -> bool:
    r"""
    Checks if the given hand shape is balanced, or semi balanced.
    Balanced hand shapes are 5-3-3-2, 4-4-3-2, 4-3-3-3.
    If semi balanced, 6-3-2-2 and 5-4-2-2 are also allowed.
    # TODO should 5M4M22 and 6M322 not be allowed?
    Parameters
    ----------
    shape : tuple
        Specified shape to check if balanced. Must sum to 13.
    semi : bool, optional
        Allow semi balanced shapes. Default is false.

    Returns
    -------
    balanced : bool
        True if hand is balanced, else false.
    """
    balanced_shapes = [(5, 3, 3, 2), (4, 4, 3, 2), (4, 3, 3, 3)]
    if semi:
        balanced_shapes.extend([(6, 3, 2, 2), (5, 4, 2, 2)])
    test_shape = tuple(sorted(shape, reverse=True))
    return test_shape in balanced_shapes


def check_if_shortage(shape: tuple) -> bool:
    r"""
    Checks if a given hand shape contains a singleton or void.

    Parameters
    ----------
    shape : tuple
        Specified shape to check if balanced. Must sum to 13.

    Returns
    -------
    shortage : bool
        True if hand contains a shortage, else false.
    """
    return 1 in shape or 0 in shape


def print_imp_table(headings: Union[List[Contract], List[Card]],
                    imps_table: Union[List[List[int]], List[List[float]]]) -> str:
    r""" Given a list of table headings, and an imps table, outputs a string for comparisons.
    The first line is the list of leads or contracts, which are to compare against. The subsequent
    lines give "my" contract or lead and the relative imp gain or loss against the other possible
    action.

    Parameters
    ----------
    headings : list
        A list of contracts or cards.

    imps_table :  list(list(float))
        The cross table of imps for the actions.

    Returns
    -------
    cross_table : str
        String representation of the table containing imp scores with headings
        of contracts or leads.
    """
    imp_strings = ["\t".join(str(imp_score)
                             for imp_score in scores) for scores in imps_table]
    cross_table = "\t"
    for header in headings:
        cross_table += f"{header}\t"
    cross_table += "\n"
    for i, header in enumerate(headings):  # type:ignore
        line = str(header) + "\t" + imp_strings[i] + "\n"
        cross_table += line
    return cross_table


def print_percentages(headings: Union[List[Contract], List[Card]], percentages: List[float]) -> str:
    r""" Given a list of table headings, and the percentages that the contract makes or the
    lead beats the contract, outputs a string of the information.
    The first line is a list of contracts or leads, and underneath are the fraction of times
    the contract makes, or the lead beats a contract.

    Parameters
    ----------
    headings : list
        A list of contracts or cards.

    percentages :  list(float)
        The list of percentages for the actions.

    Returns
    -------
    percentage_table : str
        String representation of the table containing percentages with headings
        of contracts or leads.
    """
    percentage_string = "\t".join(str(percentage)
                                  for percentage in percentages)
    percentage_table = ""
    for header in headings:
        percentage_table += f"{header}\t"
    percentage_table += f"\n{percentage_string}"
    return percentage_table
