#!/usr/bin/python3
#File: src.deal.py
"""Module containing functions and classes to generate deals."""

from __future__ import annotations
from typing import Callable, List
from random import randint
from math import factorial

from src.types import Hand, Deck, Card
from src.utils import convert_card_to_number, convert_number_to_card


def generate_deal(deal_number: int, north: Hand, east: Hand, south: Hand, west: Hand) -> Deal:
    r""" This generates a specific deal, given an integer and hands containig specified cards.

    This follows Richard Pavlicek's algorithm, specified at http://www.rpbridge.net/7z68.htm,
    but has been modified to allow for some cards already being dealt to various players.

    Initially the number of vacant spaces in each hand is calculated, and the number of cards
    left to deal out.
    New lists are generated containing the current cards in each players hands, which are
    appended to within the loop.
    The total number of possible deals given this information is calculated, and the already
    dealt out cards are
    removed from the deck.
    Given the specific deal number, the while loop goes through the remaining cards dealing
    them to each player in the order AC, KC, ... 2C, AD, ... 2D, AH, ... 2H, AS, ..., 2S.
    This ordering is due to how the cards are numbered when being put into the deck.

    Parameters
    ----------
    deal_number : int
        Number corresponding to a specific deal.
        This must come from the range [0, total_possible_deals)

    north : Hand
        Cards known to be in the North Hand. Can be just Hand([]).
    east : Hand
        Cards known to be in the East Hand. Can be just Hand([]).
    south : Hand
        Cards known to be in the South Hand. Can be just Hand([]).
    west : Hand
        Cards known to be in the West Hand. Can be just Hand([]).

    Returns
    -------
    deal : Deal
        Deal object with all 52 cards dealt out to specific players.

    """
    cards = north.hand+east.hand+south.hand+west.hand
    for card in cards:
        if cards.count(card) > 1:
            raise InvalidDealError(
                f"Deal with {cards.count(card)} copies of {card} not valid")

    spaces_in_hands = [13-len(north.hand), 13-len(east.hand),
                       13-len(south.hand), 13-len(west.hand)]
    north_hand, east_hand = north.hand.copy(), east.hand.copy()
    south_hand, west_hand = south.hand.copy(), west.hand.copy()

    cards_left_to_deal = sum(spaces_in_hands)
    space = calculate_total_possible_deals(north, east, south, west)

    remaining_cards = remove_dealt_cards(north, east, south, west)
    while cards_left_to_deal > 0:
        partition = space * spaces_in_hands[0] // cards_left_to_deal
        if deal_number < partition:
            north_hand.append(remaining_cards[cards_left_to_deal-1])
            spaces_in_hands[0] -= 1
            space = partition
            cards_left_to_deal -= 1
            continue

        deal_number -= partition
        partition = space * spaces_in_hands[1] // cards_left_to_deal
        if deal_number < partition:
            east_hand.append(remaining_cards[cards_left_to_deal-1])
            spaces_in_hands[1] -= 1
            space = partition
            cards_left_to_deal -= 1
            continue

        deal_number -= partition
        partition = space * spaces_in_hands[2] // cards_left_to_deal
        if deal_number < partition:
            south_hand.append(remaining_cards[cards_left_to_deal-1])
            spaces_in_hands[2] -= 1
            space = partition
            cards_left_to_deal -= 1
            continue

        deal_number -= partition
        partition = space * spaces_in_hands[3] // cards_left_to_deal
        if deal_number < partition:
            west_hand.append(remaining_cards[cards_left_to_deal-1])
            spaces_in_hands[3] -= 1
            space = partition
            cards_left_to_deal -= 1
            continue
    return Deal([Hand(north_hand), Hand(east_hand), Hand(south_hand), Hand(west_hand)])


def remove_dealt_cards(north: Hand, east: Hand, south: Hand, west: Hand) -> List[Card]:
    r""" Removes already dealt cards to players from the deck.

    A list of used cards is generated by converting all cards to numbers in each players'
    hand and concatenating all 4 lists.
    The Deck of cards is converted to a list of numbers.
    The used cards are then removed from the deck, and this list of numbers is
    converted to a list of cards.

    Parameters
    ----------
    north : Hand
        Cards known to be in the North Hand. Can be just Hand([]).
    east : Hand
        Cards known to be in the East Hand. Can be just Hand([]).
    south : Hand
        Cards known to be in the South Hand. Can be just Hand([]).
    west : Hand
        Cards known to be in the West Hand. Can be just Hand([]).

    Returns
    -------
    remaining_cards : list (Card)
        List of Cards not currently in any players' hand.

    """
    cards_dealt = [[convert_card_to_number(card) for card in north.hand],
                   [convert_card_to_number(card) for card in east.hand],
                   [convert_card_to_number(card) for card in south.hand],
                   [convert_card_to_number(card) for card in west.hand]]
    used_cards = [card for cards_list in cards_dealt for card in cards_list]
    deck = [convert_card_to_number(card) for card in Deck]
    remaining_cards = [convert_number_to_card(
        card) for card in deck if card not in used_cards]
    return remaining_cards


def calculate_total_possible_deals(north: Hand, east: Hand, south: Hand, west: Hand) -> int:
    r""" Given the cards already dealt out to players, calculates the total number of
    possible deals.

    This is calculated as :math: `\frac{\mathrm{cards_to_deal}!}
    {\mathrm{north_spaces}!\mathrm{east_spaces}!\mathrm{south_spaces}!\mathrm{west_spaces}!}`

    Parameters
    ----------
    north : Hand
        Cards known to be in the North Hand. Can be just Hand([]).
    east : Hand
        Cards known to be in the East Hand. Can be just Hand([]).
    south : Hand
        Cards known to be in the South Hand. Can be just Hand([]).
    west : Hand
        Cards known to be in the West Hand. Can be just Hand([]).

    Returns
    -------
    space : int
        Number of possible deals.

    """
    north_cards, east_cards = 13-len(north.hand), 13-len(east.hand)
    south_cards, west_cards = 13-len(south.hand), 13-len(west.hand)

    cards_left_to_deal = north_cards+east_cards+south_cards+west_cards
    total_permutations = factorial(cards_left_to_deal)
    north_permuatations = factorial(north_cards)
    east_permutations = factorial(east_cards)
    south_permutations = factorial(south_cards)
    west_permutations = factorial(west_cards)

    space = total_permutations//(north_permuatations*east_permutations
                                 * south_permutations*west_permutations)
    return space


class InvalidDealError(Exception):
    r"Class representing an invalid deal exception."



class Deal:
    r""" Class representing a deal object, containing 4 players' hands and can work out various
    double dummy pieces of information.

    Attributes
    ----------
    deal : list(Hand)
        A list of 4 players' hands, in the order North, East, South, West.
    north : Hand
        Cards known to be in the North Hand.
    east : Hand
        Cards known to be in the East Hand.
    south : Hand
        Cards known to be in the South Hand.
    west : Hand
        Cards known to be in the West Hand.

    Methods
    -------
    construct_from_str(hands)
        Class method which takes a list of hands given as strings to return a Deal object.

    __str__()
        Returns a string representation of the deal.

    double_dummy_score()
        Given a contract, works out the score on the hand.

    double_dummy_lead()
        Given a contract and a lead, works out the score on the hand.
    """

    def __init__(self, deal: List[Hand]) -> None:
        r"""
        Parameters
        ----------
        deal : list(Hand)
            A list of 4 hands, in the order North, East, South, West.
        """
        cards = deal[0].hand+deal[1].hand+deal[2].hand+deal[3].hand
        for card in cards:
            if cards.count(card) > 1:
                raise InvalidDealError(
                    f"Deal with {cards.count(card)} copies of {card} not valid")
        self.deal = deal
        self.north = self.deal[0]
        self.east = self.deal[1]
        self.south = self.deal[2]
        self.west = self.deal[3]

    @classmethod
    def construct_from_strings(cls, hands: List[str]) -> Deal:
        r"""
        Parameters
        ----------
        hands: list(str)
            A list of 4 strings which are converted to Hand objects.
        """
        deal = [Hand.construct_from_str(hands[i]) for i in range(4)]
        return cls(deal)

    def __str__(self) -> str:
        r""" Generates a string represenation of the deal.


        Returns
        -------
        deal_string : str
            The deal string is output as follows:
            "N: <north_hand>
            E: <east_hand>
            S: <south_hand>
            W: <west_hand>"

        """
        north, south, east, west = str(self.north), str(
            self.south), str(self.east), str(self.west)
        return f"N:{north}\nE:{east}\nS:{south}\nW:{west}"


class Dealer:
    r""" Class representing a dealer object, to generate a number of deals given
    some constraints.

    Attributes
    ----------
    hands : list(Hand)
        A list of partial hands, given in the order north, east, south west.

    accept(deal) : callable
        A function describing what deals to accept.

    deals_to_find : int
        The number of acceptable deals to generate

    Methods
    -------
    find_deals
        Finds a list of deals which pass the accept criteria.
    """

    def __init__(self, hands: List[Hand], accept: Callable[[Deal], bool] = lambda deal: True,
                 deals_to_find: int = 10) -> None:
        r"""
        Parameters
        ----------
        hands : list(Hand)
            Cards known to be in the North, East, South, West hands respectively. Can be empty.
        accept : callable, optional
            A function describing what deals to accept. Default is to accept all.
        deals_to_find : int, optional
            The number of acceptable deals to find. Default is 10.
        """
        self.hands = hands
        self.accept = accept
        self.deals_to_find = deals_to_find

    def find_deals(self) -> List[Deal]:
        r"""Generates deals which are tested by the accept function.

        This initialises a list of acceptable deals, and while the length of it is less than
        the number to find, the loop does the following:
        Generates a random integer in the interval [0, total_possible_deals).
        Converts this to a deal object.
        Tests the deal via the accept function. If accepted, append to the list,
        else continue the loop.

        Returns
        -------
        accepted_deals : list(Deal)
            List of deals which pass the accept function.
        """
        accepted_deals: List[Deal] = []
        total_possible_deals = calculate_total_possible_deals(*self.hands)
        while len(accepted_deals) < self.deals_to_find:
            deal_number = randint(0, total_possible_deals-1)
            deal = generate_deal(deal_number, *self.hands)
            if self.accept(deal):
                accepted_deals.append(deal)
        return accepted_deals
